diff --git a/backend/src/types/api-responses.types.ts b/backend/src/types/api-responses.types.ts
new file mode 100644
index 0000000..abc123
--- /dev/null
+++ b/backend/src/types/api-responses.types.ts
@@ -0,0 +1,66 @@
+/**
+ * ðŸ”’ Shared API Response Types
+ * 
+ * Eliminates 'any' types across backend services.
+ * Provides type safety for API responses and database entities.
+ * 
+ * @module types/api-responses
+ */
+
+export interface StaffMember {
+  id: string;
+  name: string;
+  email: string;
+  department: string;
+  status: 'active' | 'inactive';
+  role: string;
+  created_at: string;
+}
+
+export interface Order {
+  order_id: string;
+  user_id: string;
+  status: 'pending' | 'confirmed' | 'shipped' | 'delivered' | 'cancelled';
+  total: number;
+  created_at: string;
+  updated_at: string;
+  items?: OrderItem[];
+}
+
+export interface OrderItem {
+  item_id: string;
+  piece_id: string;
+  piece_name: string;
+  quantity: number;
+  price: number;
+}
+
+export interface User {
+  id: string;
+  email: string;
+  name: string;
+  level: number;
+  created_at: string;
+  updated_at?: string;
+}
+
+export interface Payment {
+  payment_id: string;
+  order_id: string;
+  amount: number;
+  status: 'pending' | 'completed' | 'failed';
+  method: string;
+  created_at: string;
+}
+
+export interface PaginatedResponse<T> {
+  data: T[];
+  pagination: {
+    page: number;
+    limit: number;
+    total: number;
+    totalPages: number;
+  };
+}
+
+export interface ApiResponse<T> {
+  success: boolean;
+  data: T;
+  error?: string;
+}
diff --git a/backend/src/types/dto/remix-api.dto.ts b/backend/src/types/dto/remix-api.dto.ts
new file mode 100644
index 0000000..def456
--- /dev/null
+++ b/backend/src/types/dto/remix-api.dto.ts
@@ -0,0 +1,36 @@
+/**
+ * ðŸ”’ DTOs for Remix API Service
+ * 
+ * Type-safe parameter validation for internal API calls.
+ * Replaces inline 'any' types with structured interfaces.
+ * 
+ * @module types/dto/remix-api
+ */
+
+export interface GetOrdersParams {
+  page?: number;
+  limit?: number;
+  status?: string;
+  search?: string;
+}
+
+export interface GetUsersParams {
+  page?: number;
+  limit?: number;
+  search?: string;
+  level?: number;
+}
+
+export interface GetStaffParams {
+  status?: 'active' | 'inactive';
+  department?: string;
+}
+
+export interface GetPaymentsParams {
+  page?: number;
+  limit?: number;
+  status?: string;
+  search?: string;
+  startDate?: string;
+  endDate?: string;
+}
diff --git a/backend/src/remix/remix-api.service.ts b/backend/src/remix/remix-api.service.ts
index abc123..def456 100644
--- a/backend/src/remix/remix-api.service.ts
+++ b/backend/src/remix/remix-api.service.ts
@@ -8,6 +8,12 @@
 
 import { Injectable, Inject, forwardRef } from '@nestjs/common';
 import { OrdersService } from '../database/services/orders.service';
+import {
+  StaffMember,
+  Order,
+  User,
+  Payment,
+  PaginatedResponse,
+} from '../types/api-responses.types';
+import { GetStaffParams, GetOrdersParams } from '../types/dto/remix-api.dto';
 
 @Injectable()
 export class RemixApiService {
@@ -20,7 +26,7 @@ export class RemixApiService {
   /**
    * ðŸš€ Helper HTTP simplifiÃ© - L'auth passe par le contexte Remix
    */
-  private async makeApiCall<T = any>(endpoint: string): Promise<T> {
+  private async makeApiCall<T>(endpoint: string): Promise<T> {
     try {
       const response = await fetch(`${this.baseUrl}${endpoint}`, {
         method: 'GET',
@@ -43,12 +49,7 @@ export class RemixApiService {
   /**
    * ðŸ“‹ COMMANDES - Appel direct au service (bypass guards)
    */
-  async getOrders(params: {
-    page?: number;
-    limit?: number;
-    status?: string;
-    search?: string;
-  }) {
+  async getOrders(params: GetOrdersParams): Promise<PaginatedResponse<Order>> {
     const { page = 1, limit = 20, status, search } = params;
 
     // âœ… Appel direct au service pour Ã©viter les guards HTTP
@@ -65,56 +66,52 @@ export class RemixApiService {
   /**
    * ðŸ‘¥ UTILISATEURS - Route existante
    */
-  async getUsers(params: {
-    page?: number;
-    limit?: number;
-    search?: string;
-    level?: number;
-  }) {
+  async getUsers(params: GetUsersParams): Promise<PaginatedResponse<User>> {
     const { page = 1, limit = 10, search, level } = params;
     const query = new URLSearchParams({
       page: page.toString(),
       limit: limit.toString(),
       ...(search && { search }),
       ...(level && { level: level.toString() }),
     });
 
-    return this.makeApiCall(`/api/users?${query}`);
+    return this.makeApiCall<PaginatedResponse<User>>(`/api/users?${query}`);
   }
 
   /**
    * ðŸ‘¥ STAFF - Utilise l'endpoint test-staff qui fonctionne
    */
-  async getStaff(params?: { status?: string; department?: string }) {
-    // Utiliser l'endpoint qui fonctionne dÃ©jÃ 
-    const result = await this.makeApiCall<{ data: any[] }>(
+  async getStaff(params?: GetStaffParams): Promise<StaffMember[]> {
+    const result = await this.makeApiCall<PaginatedResponse<StaffMember>>(
       '/api/users/test-staff?page=1&limit=100',
     );
 
-    // Filtrer si nÃ©cessaire
-    let staff = result.data || [];
+    let staff = result.data;
+    
     if (params?.status) {
-      staff = staff.filter((s: any) => s.status === params.status);
+      staff = staff.filter(s => s.status === params.status);
     }
     if (params?.department) {
-      staff = staff.filter((s: any) => s.department === params.department);
+      staff = staff.filter(s => s.department === params.department);
     }
 
     return staff;
   }
 
   /**
    * ðŸ“Š STAFF STATISTICS
    */
   async getStaffStatistics() {
-    const result = await this.makeApiCall<{ data: any[] }>(
+    const result = await this.makeApiCall<PaginatedResponse<StaffMember>>(
       '/api/users/test-staff?page=1&limit=100',
     );
-    const staff = result.data || [];
+    const staff = result.data;
 
     return {
       total: staff.length,
-      active: staff.filter((s: any) => s.status === 'active').length,
-      inactive: staff.filter((s: any) => s.status === 'inactive').length,
-      departments: [...new Set(staff.map((s: any) => s.department))].length,
+      active: staff.filter(s => s.status === 'active').length,
+      inactive: staff.filter(s => s.status === 'inactive').length,
+      departments: new Set(staff.map(s => s.department)).size,
     };
   }
